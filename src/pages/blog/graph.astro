---
import BaseHead from "../../components/BaseHead.astro";
import Header from "../../components/Header.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import { getCollection } from "astro:content";

const posts = await getCollection("blog");
const rootNode = { id: "__root__", title: "All Posts", type: "root" };

const categoryMap = new Map<
  string,
  {
    id: string;
    title: string;
    categories: string[];
    type: string;
  }[]
>();

const postNodes = posts.map((p) => {
  const post = {
    id: p.slug,
    title: p.data.title,
    categories: p.data.tags,
    type: "post",
  };
  p.data.tags.forEach((cat) =>
    categoryMap.has(cat)
      ? categoryMap.get(cat)?.push(post)
      : categoryMap.set(cat, [post])
  );
  return post;
});

const categoryNodes = Array.from(categoryMap.keys()).map((cat) => ({
  id: `cat_${cat}`,
  title: cat,
  type: "category",
}));

const MAX_DEGREE = 6;

const newNodes = [rootNode, ...categoryNodes, ...postNodes];

const newLinks: any[] = [];

categoryNodes.forEach((cat) => {
  const children = categoryMap.get(cat.title) || [];

  if (children.length <= MAX_DEGREE) {
    newLinks.push({ source: rootNode.id, target: cat.id });
    children.forEach((post) => {
      newLinks.push({ source: cat.id, target: post.id });
    });
  } else {
    newLinks.push({ source: rootNode.id, target: cat.id });
    let clusterIndex = 0;
    for (let i = 0; i < children.length; i += MAX_DEGREE) {
      const clusterId = `${cat.id}_cluster_${clusterIndex + 1}`;
      newNodes.push({
        id: clusterId,
        title: `${cat.title} (${clusterIndex + 1})`,
        type: "cluster",
      });
      newLinks.push({ source: cat.id, target: clusterId });

      children.slice(i, i + MAX_DEGREE).forEach((post) => {
        newLinks.push({ source: clusterId, target: post.id });
      });
      clusterIndex += 1;
    }
  }
});

const nodes = newNodes;
const links = newLinks;
---

<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      main {
        height: 100%;
      }
      #graph {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>

  <body>
    <Header position="fixed" />
    <main>
      <canvas id="graph"></canvas>
    </main>
  </body>
</html>

<script define:vars={{ links, nodes }} is:inline type="module">
  import {
    forceSimulation,
    forceLink,
    forceManyBody,
    forceCenter,
    forceCollide,
  } from "../../../node_modules/d3-force";
  import { scaleOrdinal } from "../../../node_modules/d3-scale";
  import { zoom, zoomIdentity } from "../../../node_modules/d3-zoom";
  import { select, pointer } from "../../../node_modules/d3-selection";
  import { schemeCategory10 } from "../../../node_modules/d3-scale-chromatic";

  const canvas = document.getElementById("graph");
  const ctx = canvas.getContext("2d");

  const categoryColor = "magenta";
  const clusterColor = "yellow";
  const postColor = "lightgreen";

  const categories = nodes
    .filter((n) => n.type === "category")
    .map((n) => n.id);
  const categoryColorScale = scaleOrdinal()
    .domain(categories)
    .range(schemeCategory10);

  links.forEach((link) => {
    if (link.source == "__root__") link.categoryId = link.target;
    else link.categoryId = link.source;
  });

  const simulation = forceSimulation(nodes)
    .alphaTarget(0.2)
    .force(
      "link",
      forceLink(links)
        .id((d) => d.id)
        .distance((d) => {
          if (d.source.type === "root") return 200;
          else if (d.source.type === "category") return 120;
          else if (d.source.type === "cluster") return 90;
          else return 70;
        })
    )
    .force("charge", forceManyBody().strength(-700))
    .force("center", forceCenter(window.innerWidth / 2, window.innerHeight / 2))
    .force("collide", forceCollide().radius(25))
    .on("tick", render);

  let transform = zoomIdentity;
  const zoomHandler = zoom()
    .scaleExtent([0.5, 5])
    .on("zoom", (event) => {
      transform = event.transform;
      render();
    });

  select(canvas).call(zoomHandler).on("pointermove", repel);

  let highlightedCategoryId = null;

  function repel(event) {
    const [x, y] = transform.invert(pointer(event, canvas));

    const node = simulation.find(x, y, 500);
    if (node) {
      const dx = node.x - x;
      const dy = node.y - y;
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;

      const strength = 200 / dist;
      node.vx += (dx / dist) * strength;
      node.vy += (dy / dist) * strength;
      if (node.type === "category" || node.type === "cluster") {
        highlightedCategoryId = node.id;
      } else if (node.type === "post") {
        const parentLink = links.find(
          (l) => l.target.id === node.id && l.source.type === "category"
        );
        highlightedCategoryId = parentLink ? parentLink.source.id : null;
      }
    } else highlightedCategoryId = null;
  }

  function render() {
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.translate(transform.x, transform.y);
    ctx.scale(transform.k, transform.k);

    ctx.lineWidth = 2;
    links.forEach((link) => {
      ctx.strokeStyle =
        highlightedCategoryId && highlightedCategoryId === link.categoryId
          ? categoryColorScale(link.categoryId)
          : "#555";
      ctx.beginPath();
      ctx.moveTo(link.source.x, link.source.y);
      ctx.lineTo(link.target.x, link.target.y);
      ctx.stroke();
    });

    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    nodes.forEach((node) => {
      ctx.beginPath();
      ctx.arc(node.x, node.y, 6, 0, 2 * Math.PI);
      ctx.fillStyle =
        node.type === "root"
          ? "#ffffff"
          : node.type === "category"
            ? categoryColor
            : node.type === "cluster"
              ? clusterColor
              : postColor;

      if (node.type === "root") {
        ctx.font = "1.1rem sans-serif";
      } else if (node.type === "category") {
        ctx.font = "0.92rem sans-serif";
      } else {
        ctx.font = "0.78rem sans-serif";
      }
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.fillText(node.title, node.x, node.y + 8);
    });

    ctx.restore();
  }

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    simulation.force(
      "center",
      forceCenter(canvas.width / 2, canvas.height / 2)
    );
    render();
  }
  window.addEventListener("resize", resize);
  window.addEventListener("popstate", () => window.location.reload());
  resize();
</script>
